# Python基础

## isinstance 判断对象是否属于某个类的实例

```python
class Person:
    pass


class Man(Person):
    pass


m1 = Man()
print(isinstance(m1, Man))  # True
print(isinstance(m1, Person))  # True
```

## type 查看类型

```python
class Person:
    pass


class Man(Person):
    pass


m1 = Man()
print(type(m1))  # <class '__main__.Man'>
print(type(m1) is Person)  # False
print(type(m1) is Man)  # True
```

## issubclass 一个类是否属于另外一个类的子类

```python
class Person:
    pass


class Man(Person):
    pass


class Boss(Man):
    pass


print(issubclass(Boss, Person))  # True
print(issubclass(Man, Boss))  # False
```

## _\_getattr\_\_ 与 \_\_getattribute\_\_

```python
class Person:
    def __init__(self, x):
        self.x = x

    def __getattr__(self, item):
        print('__getattr__')


p1 = Person(1)
p1.xxx  # __getattr__
```

```python
class Person:
    def __init__(self, x):
        self.x = x

    def __getattr__(self, item):
        print('__getattr__')

    def __getattribute__(self, item):
        print('__getattribute__')


p1 = Person(1)
p1.x  # __getattribute__
p1.xxx  # __getattribute__
```

```python
class Person:
    def __init__(self, x):
        self.x = x

    def __getattr__(self, item):
        print('__getattr__')

    def __getattribute__(self, item):
        print('__getattribute__')
        raise AttributeError('出现异常了')


p1 = Person(1)
p1.x
p1.xxx

# 输出结果:
# __getattribute__
# __getattr__
# __getattribute__
# __getattr__
```

## \_\_getitem\_\_  \_\_setitem\_\_  \_\_delitem\_\_

### 总结

- 通过键值对方式设置会触发 \_\_getitem\_\_  \_\_setitem\_\_  \_\_delitem\_\_
- 通过.方式会触发 \_\_getattr\_\_  \_\_setattr\_\_  \_\_delattr\_\_

```python
class Person:

    def __getitem__(self, item):
        print('__getitem__')
        return self.__dict__[item]

    def __setitem__(self, key, value):
        print('__setitem__')
        self.__dict__[key] = value

    def __delitem__(self, key):
        print('__delitem__')
        self.__dict__.pop(key)


p1 = Person()
print(p1.__dict__)  # {}

p1['key1'] = 'value1'  # 调用了 __setitem__
p1['key2'] = 'value2'  # 调用了 __setitem__

print(p1.__dict__)  # {'key1': 'value1', 'key2': 'value2'}

del p1['key1']  # 调用了 __delitem__

print(p1.__dict__)  # {'key2': 'value2'}

value = p1['key2']  # 调用了 __getitem__
print(value)  # value2
```

## \_\_str\_\_

```python
l1 = list('aaa')
print(l1)  # ['a', 'a', 'a']


class Person:
    def __str__(self):
        # 返回的必须是字符串
        return '自定义 Person 类'


p1 = Person()
print(p1)  # 自定义 Person 类
print(p1.__str__())  # 自定义 Person 类
```

## \_\_repr\_\_

```python
class Person:

    def __init__(self, x):
        self.x = x

    def __repr__(self):
        # 返回的必须是字符串
        return 'x 的值 : %s' % self.x

    pass


p1 = Person(10)
# 如果找不到 __str__ , 则寻找 __repr__
print(p1)  # x 的值 : 10

# str函数或者print函数本质触发对象的 __str__()
# repr或者交互式解释器本质触发对象的 __repr__()
# 如果 __str__ 没有被定义,那么就会使用 __repr__ 来代替输出
# 这两个方法的返回值必须是字符串,否则会抛出异常
```

## \_\_format\_\_

```python
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day


d1 = Date(2018, 1, 1)
str1 = '{0.year} {0.month} {0.day}'.format(d1)
print(str1)  # 2018 1 1
```

```python
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    def __format__(self, format_spec):
        return format_spec.format(d1)


d1 = Date(2018, 1, 1)
print(format(d1, '{0.year} {0.month} {0.day}'))  # 2018 1 1
print(format(d1, '{0.year}-{0.month}-{0.day}'))  # 2018-1-1
print(format(d1, '{0.year}:{0.month}:{0.day}'))  # 2018:1:1
```

## \_\_slots\_\_

```python
# 是一个类变量,变量值可以为列表,元祖,可迭代对象,字符串
# 作用:字典会占用大量内存,如果有一个属性很少的类,为了节省空间可以使用 __slots__ 取代实例的 __dict__
# __slots__ 会为实例使用一种更加紧凑的内部表示.实例通过一个很小的固定大小的数组来构建,而不是为每个实例定义一个字典
# 使用 __slots__ 后,不再具有 __dict__ 属性
```

```python
class Person:
    __slots__ = ['name', 'age']


p1 = Person()
p1.name = 'aa'
p1.age = 20
print(p1.name, p1.age)

# 报错,没有 __dict__
# p1.gender = 'boy'
# print(p1.__dict__)

print(Person.__slots__)  # ['name', 'age']
print(p1.__slots__)  # ['name', 'age']

p2 = Person()
p2.name = 'bb'
print(p2.name)  # bb
print(p1.name)  # aa
```

## \_\_doc\_\_

```python
# 文档属性,不能被继承

class Person:
    '我是文档描述信息'
    pass


class Man(Person):
    pass


print(Person.__doc__)  # 我是文档描述信息
print(Man.__doc__)  # None
```

## \_\_module\_\_ 与 \_\_class\_\_

```python
class Person:
    pass


p1 = Person()
print(p1.__module__)  # __main__
print(p1.__class__)  # <class '__main__.Person'>
```

## \_\_del\_\_

```python
# 析构方法,对象在内存中被释放时,进行触发

class Person:
    def __init__(self, name):
        self.name = name

    def __del__(self):
        # 实例被删除时才会进行触发
        print('__del__ 运行了')


p1 = Person('aa')
print('over')

# 打印结果:
# over
# __del__ 运行了
```

## \_\_call\_\_

```python
class Person:

    def __call__(self, *args, **kwargs):
        print('实例执行了')

    pass


p1 = Person()
p1()  # 实例执行了
```

## \_\_iter\_\_ 与 \_\_next\_\_

```python
class Person:

    def __init__(self, n=0):
        self.n = n

    def __iter__(self):
        return self

    def __next__(self):
        self.n += 1
        if self.n < 10:
            return self.n
        else:
            raise StopIteration('终止了...')


p1 = Person()
for item in p1:
    print(item)
```

```python
# 练习:斐波那契数列

import time


class Fib:
    def __init__(self):
        self._a = 1
        self._b = 1

    def __iter__(self):
        return self

    def __next__(self):
        self._a, self._b = self._b, self._a + self._b
        if self._b > 100:
            raise StopIteration("终止了..")
        return self._b


f1 = Fib()
for item in f1:
    time.sleep(0.2)
    print(item)
```

## 描述符优先级

```python
# 描述符
# 数据描述符:至少实现了 __get__() 和 __set__()
# 非数据描述符:没有实现 __set__()
```

```python
# 描述符优先级
# 从高到低
# 1.类属性
# 2.数据描述符
# 3.实例属性
# 4.非数据描述符
# 5.找不到的属性触发 __getattr__()
```

```python
class Person:
    def __set__(self, instance, value):
        print("__set__")

    def __get__(self, instance, owner):
        print("__get__")

    pass


class Room:
    p = Person()


r1 = Room()
r2 = Room()

r1.p = 1
print(r1.p)
print(Room.p)
print(r2.p)
```

